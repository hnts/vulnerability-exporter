package image

import (
	"context"
	"sync"

	"github.com/aquasecurity/trivy/pkg/report"
	"github.com/prometheus/client_golang/prometheus"
	"golang.org/x/sync/semaphore"
	"golang.org/x/xerrors"
	"k8s.io/klog/v2"
)

var (
	imageVulnerbilities = prometheus.NewGaugeVec(prometheus.GaugeOpts{
		Namespace: "trivy",
		Name:      "image_vulnerabilities",
		Help:      "Vulnerbilities of cotainer images detected by trivy",
	}, []string{
		"image",
		"layer",
		"vulnerabilityId",
		"pkgName",
		"installedVersion",
		"severity",
		"fixedVersion",
		"namespace",
		"workloadKind",
		"workloadName",
	},
	)
)

type ImageScanner struct {
	kubernetesClient KubernetesClient
	trivyClient      TrivyClient
	concurrency      uint8
}

func NewImageScanner(kclient KubernetesClient, tclient TrivyClient, concurrency uint8) *ImageScanner {
	return &ImageScanner{
		kubernetesClient: kclient,
		trivyClient:      tclient,
		concurrency:      concurrency,
	}
}

func (i *ImageScanner) Name() string {
	return "image-vulnerability-scanner"
}

func (i *ImageScanner) Scan(ctx context.Context) (prometheus.Collector, error) {
	workloads, err := i.getTargetWorkloads(ctx)
	if err != nil {
		return imageVulnerbilities, xerrors.Errorf("failed to get workloads: %w", err)
	}
	images := uniquedContainerImages(workloads)
	cacheDir := "/var/lib/trivy"

	reports, err := i.ScanImages(ctx, images, cacheDir, int64(i.concurrency))
	if err != nil {
		return imageVulnerbilities, err
	}

	imageVulnerbilities.Reset()
	for _, rp := range reports {
		for _, w := range workloads {
			for _, i := range w.images {
				if rp.ArtifactName == i {
					for _, rs := range rp.Results {
						for _, v := range rs.Vulnerabilities {
							labels := []string{
								rp.ArtifactName,
								v.Layer.DiffID,
								v.VulnerabilityID,
								v.PkgName,
								v.InstalledVersion,
								v.Severity,
								v.FixedVersion,
								w.namespace,
								w.kind,
								w.name,
							}
							imageVulnerbilities.WithLabelValues(labels...).Set(1)
						}
					}
				}
			}
		}
	}

	return imageVulnerbilities, nil
}

func (i *ImageScanner) CleanUp() error {
	return nil
}

func (i *ImageScanner) ScanImages(ctx context.Context, images []string, cacheDir string, concurrency int64) ([]report.Report, error) {
	err := i.trivyClient.UpdateDatabase(ctx, cacheDir)
	if err != nil {
		return nil, xerrors.Errorf("failed to update trivy database: %w", err)
	}

	wg := sync.WaitGroup{}
	mutex := &sync.Mutex{}
	reports := []report.Report{}
	sem := semaphore.NewWeighted(concurrency)
	for _, image := range images {
		wg.Add(1)
		if err := sem.Acquire(ctx, 1); err != nil {
			klog.Warningf("failed to acquire semaphore: %w", err)
			continue
		}

		go func(image string) {
			defer func() {
				sem.Release(1)
				wg.Done()
			}()

			report, err := i.trivyClient.ScanImage(ctx, image, cacheDir)
			if err != nil {
				klog.Warningf("failed to scan image(%s): %s", image, err)
				return
			}

			mutex.Lock()
			reports = append(reports, *report)
			mutex.Unlock()
		}(image)
	}
	wg.Wait()

	return reports, nil
}

type workload struct {
	name      string
	namespace string
	kind      string
	images    []string
}

func (i *ImageScanner) getTargetWorkloads(ctx context.Context) ([]workload, error) {
	var workloads []workload

	deployments, err := i.kubernetesClient.ListDeployments(ctx)
	if err != nil {
		return nil, err
	}
	for _, d := range deployments {
		w := workload{
			name:      d.Name,
			namespace: d.Namespace,
			kind:      "Deployment",
			images: func() []string {
				var images []string
				for _, c := range d.Spec.Template.Spec.Containers {
					images = append(images, c.Image)
				}
				return images
			}(),
		}
		workloads = append(workloads, w)
	}

	statefulSets, err := i.kubernetesClient.ListStatefulSets(ctx)
	if err != nil {
		return nil, err
	}
	for _, s := range statefulSets {
		w := workload{
			name:      s.Name,
			namespace: s.Namespace,
			kind:      "StatefulSet",
			images: func() []string {
				var images []string
				for _, c := range s.Spec.Template.Spec.Containers {
					images = append(images, c.Image)
				}
				return images
			}(),
		}
		workloads = append(workloads, w)
	}

	daemonSets, err := i.kubernetesClient.ListDaemonSets(ctx)
	if err != nil {
		return nil, err
	}
	for _, d := range daemonSets {
		w := workload{
			name:      d.Name,
			namespace: d.Namespace,
			kind:      "DaemonSet",
			images: func() []string {
				var images []string
				for _, c := range d.Spec.Template.Spec.Containers {
					images = append(images, c.Image)
				}
				return images
			}(),
		}
		workloads = append(workloads, w)
	}

	cronJobs, err := i.kubernetesClient.ListCronJobs(ctx)
	if err != nil {
		return nil, err
	}
	for _, c := range cronJobs {
		w := workload{
			name:      c.Name,
			namespace: c.Namespace,
			kind:      "Deployment",
			images: func() []string {
				var images []string
				for _, c := range c.Spec.JobTemplate.Spec.Template.Spec.Containers {
					images = append(images, c.Image)
				}
				return images
			}(),
		}
		workloads = append(workloads, w)
	}

	return workloads, err
}

func uniquedContainerImages(workloads []workload) []string {
	var images []string

	for _, w := range workloads {
		images = append(images, w.images...)
	}

	keys := make(map[string]bool)
	var uimages []string
	for _, image := range images {
		if _, value := keys[image]; !value {
			keys[image] = true
			uimages = append(uimages, image)
		}
	}

	return uimages
}
