package node

import (
	"context"
	"encoding/json"

	"github.com/aquasecurity/trivy/pkg/report"
	"github.com/prometheus/client_golang/prometheus"
	"golang.org/x/xerrors"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/klog/v2"
)

var (
	nodeVulnerbilities = prometheus.NewGaugeVec(prometheus.GaugeOpts{
		Namespace: "trivy",
		Name:      "node_vulnerabilities",
		Help:      "Vulnerbilities of cluster node detected by trivy",
	}, []string{
		"nodeName",
		"vulnerabilityId",
		"pkgName",
		"installedVersion",
		"severity",
		"fixedVersion",
	},
	)
)

var pod = &v1.Pod{
	TypeMeta: metav1.TypeMeta{
		Kind:       "Pod",
		APIVersion: "v1",
	},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app": "trivy-node-scanner",
		},
	},
	Spec: v1.PodSpec{
		Affinity: &v1.Affinity{
			NodeAffinity: &v1.NodeAffinity{
				RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
					NodeSelectorTerms: []v1.NodeSelectorTerm{
						{
							MatchExpressions: []v1.NodeSelectorRequirement{
								{
									Key:      "kubernetes.io/hostname",
									Operator: v1.NodeSelectorOpIn,
								},
							},
						},
					},
				},
			},
		},
		Tolerations: []v1.Toleration{
			{
				Key:    "node-role.kubernetes.io/master",
				Effect: v1.TaintEffectNoSchedule,
			},
		},
		Containers: []v1.Container{
			{
				Name:  "trivy",
				Image: "ghcr.io/aquasecurity/trivy:0.22.0",
				Args: []string{
					"--quiet",
					"rootfs",
					"--format",
					"json",
					"--no-progress",
					"--skip-dirs",
					"/host/proc",
					"/host",
				},
				VolumeMounts: []v1.VolumeMount{
					{
						Name:      "host",
						MountPath: "/host",
					},
				},
			},
		},
		RestartPolicy: v1.RestartPolicyNever,
		Volumes: []v1.Volume{
			{
				Name: "host",
				VolumeSource: v1.VolumeSource{
					HostPath: &v1.HostPathVolumeSource{
						Path: "/",
					},
				},
			},
		},
	},
}

type NodeScanner struct {
	kubernetesClient KubernetesClient
	namespace        string
}

func NewNodeScanner(kclient KubernetesClient, ns string) *NodeScanner {
	return &NodeScanner{
		kubernetesClient: kclient,
		namespace:        ns,
	}
}

func (n *NodeScanner) Name() string {
	return "node-vulnerability-scanner"
}

func (n *NodeScanner) Scan(ctx context.Context) (prometheus.Collector, error) {
	nodes, err := n.kubernetesClient.ListNodes(ctx)
	if err != nil {
		return nodeVulnerbilities, xerrors.Errorf("failed to list nodes for scanning: %w", err)
	}

	for _, node := range nodes {
		report, err := n.ScanNode(ctx, node)
		if err != nil {
			klog.Warningf("failed to scan node(%s): %s", node.Name, err)
			continue
		}

		for _, rs := range report.Results {
			for _, v := range rs.Vulnerabilities {
				labels := []string{
					node.Name,
					v.VulnerabilityID,
					v.PkgName,
					v.InstalledVersion,
					v.Severity,
					v.FixedVersion,
				}
				nodeVulnerbilities.WithLabelValues(labels...).Set(1)
			}
		}
	}

	return nodeVulnerbilities, nil
}

func (n *NodeScanner) CleanUp() error {
	labelSelector := &metav1.LabelSelector{
		MatchLabels: map[string]string{
			"app": "trivy-node-scanner",
		},
	}

	pods, err := n.kubernetesClient.ListPodsByLabel(context.Background(), labelSelector)
	if err != nil {
		return xerrors.Errorf("failed to list the remaining pods scanning nodes: %s", err)
	}

	for _, p := range pods {
		err := n.kubernetesClient.DeletePod(context.Background(), p.Namespace, p.Name)
		if err != nil {
			return xerrors.Errorf("failed to delete pod(%s): %s", pod.Name, err)
		}
	}

	return nil
}

func (n *NodeScanner) ScanNode(ctx context.Context, node v1.Node) (*report.Report, error) {
	pod.Name = "trivy-" + node.Name
	pod.Spec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms[0].MatchExpressions[0].Values = []string{node.Name}

	err := n.kubernetesClient.CreatePod(ctx, n.namespace, pod)
	if err != nil {
		return nil, xerrors.Errorf("failed to create pod(%s) for scanning node: %s", pod.Name, err)
	}

	defer func() {
		err = n.kubernetesClient.DeletePod(context.Background(), n.namespace, pod.Name)
		if err != nil {
			klog.Warningf("failed to delete pod(%s) after scanning %s: %s", pod.Name, node.Name, err)
		}
	}()

	err = n.kubernetesClient.WaitUntilCompleted(n.namespace, pod.Name)
	if err != nil {
		return nil, xerrors.Errorf("failed to complete pod(%s) for scanning node: %s", pod.Name, err)
	}

	containerName := "trivy"
	log, err := n.kubernetesClient.GetContainerLog(ctx, n.namespace, pod.Name, containerName)
	if err != nil {
		return nil, err
	}

	var report report.Report
	err = json.Unmarshal([]byte(log), &report)
	if err != nil {
		return nil, err
	}

	return &report, nil
}
