package kubernetes

import (
	"bytes"
	"context"
	"io"

	"golang.org/x/xerrors"
	appv1 "k8s.io/api/apps/v1"
	batchv1 "k8s.io/api/batch/v1"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

type Client struct {
	clientSet kubernetes.Interface
}

func NewClient(clientSet kubernetes.Interface) Client {
	return Client{
		clientSet: clientSet,
	}
}

func (c Client) CreatePod(ctx context.Context, ns string, pod *v1.Pod) error {
	_, err := c.clientSet.CoreV1().Pods(ns).Create(ctx, pod, metav1.CreateOptions{})
	if err != nil {
		return xerrors.Errorf("failed to create pod %s: %w", pod.Name, err)
	}

	return nil
}

func (c Client) DeletePod(ctx context.Context, ns string, name string) error {
	err := c.clientSet.CoreV1().Pods(ns).Delete(ctx, name, metav1.DeleteOptions{})
	if err != nil {
		return xerrors.Errorf("failed to delete pod %s: %w", name, err)
	}

	return nil
}

func (c Client) GetPod(ctx context.Context, name string, ns string) (*v1.Pod, error) {
	pod, err := c.clientSet.CoreV1().Pods(ns).Get(ctx, name, metav1.GetOptions{})
	if err != nil {
		return nil, xerrors.Errorf("failed to get pod %s: %w", name, err)
	}

	return pod, nil
}

func (c Client) ListPodsByLabel(ctx context.Context, label *metav1.LabelSelector) ([]v1.Pod, error) {
	pods, err := c.clientSet.CoreV1().Pods("").List(ctx, metav1.ListOptions{
		LabelSelector: metav1.FormatLabelSelector(label),
	})
	if err != nil {
		return nil, err
	}

	return pods.Items, nil
}

func (c Client) GetContainerLog(ctx context.Context, ns string, podName string, containerName string) (string, error) {
	req := c.clientSet.CoreV1().Pods(ns).GetLogs(podName, &v1.PodLogOptions{Container: containerName})

	body, err := req.Stream(ctx)
	if err != nil {
		return "", xerrors.Errorf("failed to open stream: %w", err)
	}
	defer body.Close()

	var log bytes.Buffer
	n, err := io.Copy(&log, body)
	if err != nil {
		return "", xerrors.New("failed to copy information from body to log")
	}
	if n == 0 {
		return "", xerrors.New("The log retrieved from the pod is empty")
	}

	return log.String(), nil
}

func (c Client) ListNodes(ctx context.Context) ([]v1.Node, error) {
	nodes, err := c.clientSet.CoreV1().Nodes().List(ctx, metav1.ListOptions{})
	if err != nil {
		return []v1.Node{}, xerrors.Errorf("failed to list nodes: %w", err)
	}

	return nodes.Items, nil
}

func (c Client) WaitUntilCompleted(namespace string, podName string) error {
	ctx := context.Background()
	w, err := c.clientSet.CoreV1().Pods(namespace).Watch(ctx, metav1.ListOptions{})
	if err != nil {
		return xerrors.Errorf("failed to watch pods: %w", err)
	}

	defer w.Stop()

	ch := w.ResultChan()
	for {
		select {
		case <-ctx.Done():
			return xerrors.New("pod execution timeout")
		case obj := <-ch:
			pod, ok := obj.Object.(*v1.Pod)
			if !ok {
				return xerrors.Errorf("failed to cast to pod from watch object: %w", obj)
			}

			if pod.Name == podName {
				if pod.Status.Phase == "Succeeded" {
					return nil
				}

				if pod.Status.Phase == "Failed" {
					return xerrors.Errorf("The status of the pod is \"Failed\" because %s", pod.Status.Reason)
				}
			}
		}
	}
}

func (c Client) ListDeployments(ctx context.Context) ([]appv1.Deployment, error) {
	deployments, err := c.clientSet.AppsV1().Deployments("").List(ctx, metav1.ListOptions{})
	if err != nil {
		return []appv1.Deployment{}, xerrors.Errorf("failed to list deployments: %w", err)
	}

	return deployments.Items, nil
}

func (c Client) ListStatefulSets(ctx context.Context) ([]appv1.StatefulSet, error) {
	statefulSets, err := c.clientSet.AppsV1().StatefulSets("").List(ctx, metav1.ListOptions{})
	if err != nil {
		return []appv1.StatefulSet{}, xerrors.Errorf("failed to list statefulsets: %w", err)
	}

	return statefulSets.Items, nil
}

func (c Client) ListDaemonSets(ctx context.Context) ([]appv1.DaemonSet, error) {
	daemonSets, err := c.clientSet.AppsV1().DaemonSets("").List(ctx, metav1.ListOptions{})
	if err != nil {
		return []appv1.DaemonSet{}, xerrors.Errorf("failed to list daemonsets: %w", err)
	}

	return daemonSets.Items, nil
}

func (c Client) ListCronJobs(ctx context.Context) ([]batchv1.CronJob, error) {
	cronJobs, err := c.clientSet.BatchV1().CronJobs("").List(ctx, metav1.ListOptions{})
	if err != nil {
		return []batchv1.CronJob{}, xerrors.Errorf("failed to list cronjob: %w", err)
	}

	return cronJobs.Items, nil
}
