package exporter

import (
	"context"
	"net/http"
	"sync"
	"time"

	"github.com/hnts/vulnerability-exporter/pkg/scanner"
	"github.com/prometheus/client_golang/prometheus"
	"k8s.io/klog/v2"
)

type Exporter struct {
	scanners []scanner.Scanner
	metrics  []prometheus.Collector
	server   http.Server
}

func NewExporter(scanners []scanner.Scanner, server http.Server) *Exporter {
	return &Exporter{
		scanners: scanners,
		metrics:  []prometheus.Collector{},
		server:   server,
	}
}

func (e *Exporter) Listen(ctx context.Context, interval time.Duration) {
	go func() {
		e.execute(ctx)
		ticker := time.NewTicker(interval)
	LOOP:
		for {
			select {
			case <-ticker.C:
				e.execute(ctx)
			case <-ctx.Done():
				ticker.Stop()
				break LOOP
			}
		}
	}()

	go func() {
		if err := e.server.ListenAndServe(); err != http.ErrServerClosed {
			klog.Fatalf("failed to start server: %s", err)
		}
	}()

	<-ctx.Done()
	klog.Info("Now that sigterm has been detected, run the cleanup and shutdown server...")
	e.cleanup()
	err := e.server.Shutdown(context.Background())
	if err != nil {
		klog.Warningf("failed to shutdown server: %s", err)
	}
}

func (e *Exporter) Describe(ch chan<- *prometheus.Desc) {
	for _, c := range e.metrics {
		c.Describe(ch)
	}
}
func (e *Exporter) Collect(ch chan<- prometheus.Metric) {
	for _, c := range e.metrics {
		c.Collect(ch)
	}
}

func (e *Exporter) execute(ctx context.Context) {
	metrics := []prometheus.Collector{}
	for _, s := range e.scanners {
		c, err := s.Scan(ctx)
		if err != nil {
			klog.Warningf("failed to execute Scan of %s: %s", s.Name(), err)
		}
		metrics = append(metrics, c)
	}

	e.metrics = metrics
}

func (e *Exporter) cleanup() {
	wg := sync.WaitGroup{}
	for _, s := range e.scanners {
		wg.Add(1)
		go func(s scanner.Scanner) {
			defer wg.Done()
			err := s.CleanUp()
			if err != nil {
				klog.Warningf("failed to clean up %s: %s", s.Name(), err)
			}
		}(s)
	}
	wg.Wait()
}
