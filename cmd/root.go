package cmd

import (
	"context"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/hnts/vulnerability-exporter/pkg/exporter"
	k8s "github.com/hnts/vulnerability-exporter/pkg/kubernetes"
	"github.com/hnts/vulnerability-exporter/pkg/scanner"
	"github.com/hnts/vulnerability-exporter/pkg/scanner/image"
	"github.com/hnts/vulnerability-exporter/pkg/scanner/node"
	"github.com/hnts/vulnerability-exporter/pkg/trivy"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/spf13/cobra"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/klog/v2"
)

var (
	listenAddress  string
	metricsPath    string
	usedNamespace  string
	kubeConfigPath string
	scanInterval   int32

	rootCmd = &cobra.Command{
		Use:   "vulnerability-exporter",
		Short: "A Prometheus Exporter for managing vulnerabilities in kubernetes by using trivy",
		Run: func(cmd *cobra.Command, args []string) {
			defer klog.Flush()

			var config *rest.Config
			var configErr error

			if kubeConfigPath != "" {
				config, configErr = clientcmd.BuildConfigFromFlags("", kubeConfigPath)
			} else {
				config, configErr = rest.InClusterConfig()
			}

			if configErr != nil {
				klog.Fatalf("failed to initialize kube config: %s", configErr.Error())
			}

			clientset, err := kubernetes.NewForConfig(config)
			if err != nil {
				klog.Fatalf("failed to create kubernetes client: %s", err.Error())
			}

			kclient := k8s.NewClient(clientset)
			tclient := trivy.Client{}
			scanners := []scanner.Scanner{
				image.NewImageScanner(kclient, tclient),
				node.NewNodeScanner(kclient, usedNamespace),
			}

			mux := http.NewServeMux()
			mux.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) })
			mux.Handle(metricsPath, promhttp.Handler())

			server := http.Server{
				Addr:    listenAddress,
				Handler: mux,
			}
			exporter := exporter.NewExporter(scanners, server)
			prometheus.MustRegister(exporter)

			ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
			defer stop()

			klog.Info("Start vulnerability-exporter")
			exporter.Listen(ctx, time.Duration(scanInterval)*time.Second)
		},
	}
)

func Execute() {
	err := rootCmd.Execute()
	if err != nil {
		os.Exit(1)
	}
}

func init() {
	klog.InitFlags(nil)

	rootCmd.Flags().StringVar(&listenAddress, "listen-address", ":9321", "Address to listen on for web interface and telemetry")
	rootCmd.Flags().StringVar(&metricsPath, "metrics-path", "/metrics", "Path under which to expose metrics")
	rootCmd.Flags().StringVar(&usedNamespace, "used-namespace", "default", "Namespace in which the Pod that scans nodes for vulnerabilities is created")
	rootCmd.Flags().StringVar(&kubeConfigPath, "kubeconfig", "", "Absolute path to the kubeconfig file")
	rootCmd.Flags().Int32Var(&scanInterval, "scan-interval", 6000, "Seconds in the interval to execute to scan vulnerability")
}
